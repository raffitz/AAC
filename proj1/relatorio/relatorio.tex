\documentclass[a4paper]{article}

\usepackage{tecnico_relatorio}

\begin{document}
	\trSetImage{tecnico_logo}{6cm} % Logotipo do Técnico
	\trSetSubject{Arquitecturas Avançadas de Computadores}
	\trSetType{Laboratório I}
	\trSetTitle{Simulação de um microprocessador $\mu$RISC com funcionamento multi-ciclo}
	
	\trSetBoxStyle{0.3}
	
	\trSetAuthorNr{3}
	
	\trSetAuthors
		{
		Gonçalo Ribeiro
		
		73294
		}{
		Miguel Costa
		
		73359
		}{
		Rafael Gonçalves
		
		73786
		}
	
	
	\trMakeCover
	
	\tableofcontents
	\pagebreak
	
	\section{Introdução}
	
		Nesta actividade laboratorial pretende-se desenvolver um processador $\mu$RISC com descrição em VHDL. Pretende-se que este processador com arquitectura RISC de 16 bits e funcionamento multi-ciclo execute 42 instruções diferentes, demorando 4 ciclos para completar cada uma. Ao primeiro ciclo (Instruction Fetch-IF), a próxima instrução a ser executada é carregada da memória e armazenada no registo de instruções. No segundo ciclo (Instruction Decode-ID) a instrução anteriormente carregada é descodificada e os operandos são lidos do Register File (RF). O terceiro ciclo (Execution-EX) consiste na execução da instrução e cálculo das condições dos resultados. Por fim, no quarto ciclo (Write Back- WB) os resultados são escritos no RF.
	
		Tal como já foi referido, é um processador de 16 bits que contém 8 registos de uso geral, cada um com 16 bits de largura. Existem 42 instruções possíveis de executar, sendo estas compostas por até 3 operandos. Quanto à memória esta é do tipo big endian, sendo endereçável ao nível da palavra.
	
	
	\section{Arquitectura}
	
		\subsection{IF}
		
			\subsubsection{ROM}
			
			\subsubsection{PC}
		
		\subsection{IDRF}
			
			
			
			
			
			\subsubsection{RF}
			
		\subsection{EX}
		
			\begin{figure}[H]
				\centering	
				\includegraphics[width=\textwidth]{ex}
				\caption{Bloco de Execução e acesso à memória}
				\label{fig:ex}
			\end{figure}
		
			Neste módulo são executadas as instruções e calculadas as condições de resultados. Podemos então considerar 3 grandes componentes que funcionam neste ciclo: ALU, Flag Tester e RAM.
			
			Tal como é visível na Figura~\ref{fig:ex}, podemos ainda considerar lógica adicional, correspondente ao \textit{load} de constantes. Como o processador permite o carregamente de constantes para a parte \textit{high} ou parte \textit{low}, é feita aqui essa concatenação, sendo que depois é feita uma multiplexagem para os restantes casos de carregamento de constantes (que provêm do \textit{Signal Extender} em IDRF).
		
			\subsubsection{ALU}
				
				O componente da ALU é responsável por rececer 2 operandos ($A$ e $B$), efectuar uma dada operação sobre estes (aritmética, deslocamento lógico ou lógica), dando um resultado $C$.
				
				Este componente é divisível em 3 subcomponentes: componente aritmética, lógica e shifts. É neste componente que são geradas as \textit{flags}, consoante a operação a executar. Existem então 4 \textit{flags}: \textit{signal} ($S$), \textit{carry} ($C$), \textit{zero} ($Z$) e \textit{overflow} ($V$). Mais à frente são descritas as funcionalidades destas e quais as suas utilidades.
				
				O primeiro sub-componente é responsável por executar qualquer função aritmética: soma, subtração e as suas variantes. É de notar que nestas operações todas as \textit{flags} são actualizadas neste bloco.
				
				O componente responsável por fazer os deslocamentos lógicos (shifts) apenas tem que efectuar duas operações: shift aritmético direito e shift lógico esquerdo. Neste bloco são actualizadas as \textit{flags} de signal, zero e carry.
				
				Por último, a unidade lógica é responsável por efectuar todas as operações lógicas: and, or, xor, pass, nor, nand, entre outras. Neste componente, por a actualização das \textit{flags} ser independente de operação para operação, é apenas feita a actualização das que forem necessárias (zero, signal ou nenhuma).
			
			\subsubsection{RAM}
				
				O bloco de memória RAM, tal como já foi referido, é endereçável ao nível da palavra, sendo que cada endereço de memória corresponde então a uma palavra de 2 bytes. Se o processador tem 16 bits de endereço, então a capacidade total de memória do processador é de 32 KB. Esta memória funciona com leitura assíncrona e escrita síncrona caso o enable de escrita se encontre activo ($we = '1'$).
				
				Quanto à descrição \emph{VHDL}, a memória tem como sinal de entrada $data_in$, de saída $data_out$ e de endereço $addr$, ou seja, para as instruções existentes de acesso à memória temos que podem ser feitas as operações de \texttt{LOAD} e \texttt{STORE}. Quanto à primeira é carregado para um registo $C$ o valor da memória endereçável pelo conteúdo do registo $A$; quanto à segunda instrução é armazenado o conteúdo do registo $B$ no endereço de memória apontado pelo conteúdo do registo $A$.
				
			\subsubsection{Flag Tester}
			
				Quanto à actualização das \textit{flags}, tal como já foi referido, o método utilizado baseia-se em actualizar apenas as \textit{flags} necessárias, ou seja, todas as \textit{flags} guardadas entram dentro da ALU, mas dependo da instrução a executar, é feita uma concatenação das \textit{flags} a actualizar com as que não serão actualizadas. No entanto, no caso de ser uma operação aritmética, todas as \textit{flags} são actualizadas.
			
				O componente de Flag Tester serve então para indicar se se deve efectuar um determinado salto ou não dependendo se é instrução de salto ou se as condições de flag são válidas para que se efectue esse salto. Temos então como sinais de entrada as quatro \textit{flags}, o código correspondente à condição de salto, o código da operação a efectuar (para distinguir os vários tipos de salto), um \textit{enable} e como sinais de saída os valores das \textit{flags} armazendos em registos e ainda um sinal $s$ que indicará qual valor de PC a utilizar, se PC+1 ou se um outro valor de PC. Em primeiro lugar é verificada a condição de salto de acordo com os sinais presentes nos registos das \textit{flags}, a operação de salto, e caso se verifique que a condição é verdadeira para o salto indicado, então é colocado $s$ com valor lógico ‘1’. Caso a condição não seja cumprida, é colocado o valor lógico ‘0’. 
				
				À saída deste bloco temos ainda lógica adicional para indicar caso não seja uma operação de salto (\textit{mux} regulado por $is\_jump$), sendo que se for um jump \texttt{True} ou \texttt{False}, é mandado o sinal proveniente do \emph{Flag Tester}, mas caso seja um outro tipo de salto (por exemplo, \texttt{Inconditional jump}), seja carregado na mesma o valor do salto e não PC+1.
			
		\subsection{WB}
		
		\subsection{Máquina de Estados}
		
	\section{Testes e Simulações}
	
		\subsection{Fibonacci}
		
	\section{Conclusão}
	
\end{document}

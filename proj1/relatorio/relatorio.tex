\documentclass[a4paper]{article}

\usepackage{tecnico_relatorio}

\begin{document}
	\trSetImage{tecnico_logo}{6cm} % Logotipo do Técnico
	\trSetSubject{Arquitecturas Avançadas de Computadores}
	\trSetType{Laboratório I}
	\trSetTitle{Simulação de um microprocessador $\mu$RISC com funcionamento multi-ciclo}
	
	\trSetBoxStyle{0.3}
	
	\trSetAuthorNr{3}
	
	\trSetAuthors
		{
		Gonçalo Ribeiro
		
		73294
		}{
		Miguel Costa
		
		73359
		}{
		Rafael Gonçalves
		
		73786
		}
	
	
	\trMakeCover
	
	\tableofcontents
	\pagebreak
	
	\section{Introdução}
	
		Nesta actividade laboratorial pretende-se desenvolver um processador $\mu$RISC com descrição em VHDL. Pretende-se que este processador com arquitectura RISC de 16 bits e funcionamento multi-ciclo execute 42 instruções diferentes, demorando 4 ciclos para completar cada uma. Ao primeiro ciclo (Instruction Fetch - IF), a próxima instrução a ser executada é carregada da memória e armazenada no registo de instruções. No segundo ciclo (Instruction Decode - ID) a instrução anteriormente carregada é descodificada e os operandos são lidos do Register File (RF). O terceiro ciclo (Execution - EX) consiste na execução da instrução e cálculo das condições dos resultados. Por fim, no quarto ciclo (Write Back - WB) os resultados são escritos no RF.
	
		Tal como já foi referido, é um processador de 16 bits que contém 8 registos de uso geral, cada um com 16 bits de largura. Existem 42 instruções possíveis de executar, sendo estas compostas por até 3 operandos. Quanto à memória esta é do tipo big endian, sendo endereçável ao nível da palavra.
	
	
	\section{Arquitectura}
	
		\subsection{IF}
		
			\subsubsection{ROM}
			
			\subsubsection{PC}
		
		\subsection{IDRF}
			
			Neste módulo são gerados vários sinais de controlo com base na instrução obtida do IF. Para além do mais, com base nessa instrução é também feita a leitura assíncrona dos registos envolvidos na operação (operandos).
			
			Entre os sinais de controlo gerados neste bloco encontram-se:
			
			\begin{itemize}
				\item A operação da ALU, que corresponde a uma cadeia de bits da instrução, salvo no caso de se tratar de um salto ou de carregamento de uma constante (nesse caso é passada a operação necessária);
				\item Os sinais de controlo dos multiplexers das duas entradas da ALU, que variam consoante a operação;
				\item A condição e o tipo de salto, bem como um sinal a indicar se a instrução é, de facto um salto, ou se estes valores devem ser ignorados;
				\item Um sinal que só permite a alteração das \textit{flags} quando a instrução é executada ao nível da ALU (por oposição a uma leitura ou escrita da memória);
				\item Sinais relativos ao carregamento de constantes para a parte \textit{high} ou \textit{low} de um registo, ou para o carregamento de imediatos;
				\item Um sinal de controlo para a escrita na memória;
				\item Sinais de controlo a ser passados para o Write Back com o endereço do registo de destino do resultado, bem como os \textit{enables} relevantes.
			\end{itemize}
			
			\subsubsection{RF}
				
				O bloco de registos contém 8 registos de 16 bits cada, com dois portos de leitura assíncrona e um porto de escrita síncrona.
				
				Os endereços de leitura provêm dos mesmos bits de instrução, excepto quando é feito o carregamento de um só byte para as partes \textit{high} ou \textit{low} da palavra. Nesse caso, o endereço do porto de leitura A é substituído pelo do registo de leitura e escrita.
				
				O endereço de escrita vem do Write Back, sendo que o \textit{enable} de escrita deste bloco está ligado ao \textit{enable} do Write Back, e não ao do módulo IDRF.
			
		\subsection{EX}
		
			\begin{figure}[H]
				\centering	
				\includegraphics[width=\textwidth]{ex}
				\caption{Bloco de Execução e acesso à memória}
				\label{fig:ex}
			\end{figure}
		
			Neste módulo são executadas as instruções e calculadas as condições de resultados. Podemos então considerar 3 grandes componentes que funcionam neste ciclo: ALU, Flag Tester e RAM.
			
			Tal como é visível na Figura~\ref{fig:ex}, podemos ainda considerar lógica adicional, correspondente ao \textit{load} de constantes. Como o processador permite o carregamente de constantes para a parte \textit{high} ou parte \textit{low}, é feita aqui essa concatenação, sendo que depois é feita uma multiplexagem para os restantes casos de carregamento de constantes (que provêm do \textit{Signal Extender} em IDRF).
		
			\subsubsection{ALU}
				
				O componente da ALU é responsável por rececer 2 operandos ($A$ e $B$), efectuar uma dada operação sobre estes (aritmética, deslocamento lógico ou lógica), dando um resultado $C$.
				
				Este componente é divisível em 3 subcomponentes: componente aritmética, lógica e shifts. É neste componente que são geradas as \textit{flags}, consoante a operação a executar. Existem então 4 \textit{flags}: \textit{signal} ($S$), \textit{carry} ($C$), \textit{zero} ($Z$) e \textit{overflow} ($V$). Mais à frente são descritas as funcionalidades destas e quais as suas utilidades.
				
				O primeiro sub-componente é responsável por executar qualquer função aritmética: soma, subtração e as suas variantes. É de notar que nestas operações todas as \textit{flags} são actualizadas neste bloco.
				
				O componente responsável por fazer os deslocamentos lógicos (shifts) apenas tem que efectuar duas operações: shift aritmético direito e shift lógico esquerdo. Neste bloco são actualizadas as \textit{flags} de signal, zero e carry.
				
				Por último, a unidade lógica é responsável por efectuar todas as operações lógicas: and, or, xor, pass, nor, nand, entre outras. Neste componente, por a actualização das \textit{flags} ser independente de operação para operação, é apenas feita a actualização das que forem necessárias (zero, signal ou nenhuma).
			
			\subsubsection{RAM}
				
				O bloco de memória RAM, tal como já foi referido, é endereçável ao nível da palavra, sendo que cada endereço de memória corresponde então a uma palavra de 2 bytes. Se o processador tem 16 bits de endereço, então a capacidade total de memória do processador é de 32 KB. Esta memória funciona com leitura assíncrona e escrita síncrona caso o enable de escrita se encontre activo ($we~=~'1'$).
				
				Quanto à descrição \emph{VHDL}, a memória tem como sinal de entrada $data_in$, de saída $data_out$ e de endereço $addr$, ou seja, para as instruções existentes de acesso à memória temos que podem ser feitas as operações de \texttt{LOAD} e \texttt{STORE}. Quanto à primeira é carregado para um registo $C$ o valor da memória endereçável pelo conteúdo do registo $A$; quanto à segunda instrução é armazenado o conteúdo do registo $B$ no endereço de memória apontado pelo conteúdo do registo $A$.
				
			\subsubsection{Flag Tester}
			
				Quanto à actualização das \textit{flags}, tal como já foi referido, o método utilizado baseia-se em actualizar apenas as \textit{flags} necessárias, ou seja, todas as \textit{flags} guardadas entram dentro da ALU, mas dependo da instrução a executar, é feita uma concatenação das \textit{flags} a actualizar com as que não serão actualizadas. No entanto, no caso de ser uma operação aritmética, todas as \textit{flags} são actualizadas.
			
				O componente de Flag Tester serve então para indicar se se deve efectuar um determinado salto ou não dependendo se é instrução de salto ou se as condições de flag são válidas para que se efectue esse salto. Temos então como sinais de entrada as quatro \textit{flags}, o código correspondente à condição de salto, o código da operação a efectuar (para distinguir os vários tipos de salto), um \textit{enable} e como sinais de saída os valores das \textit{flags} armazendos em registos e ainda um sinal $s$ que indicará qual valor de PC a utilizar, se PC+1 ou se um outro valor de PC. Em primeiro lugar é verificada a condição de salto de acordo com os sinais presentes nos registos das \textit{flags}, a operação de salto, e caso se verifique que a condição é verdadeira para o salto indicado, então é colocado $s$ com valor lógico ‘1’. Caso a condição não seja cumprida, é colocado o valor lógico ‘0’. 
				
				À saída deste bloco temos ainda lógica adicional para indicar caso não seja uma operação de salto (\textit{mux} regulado por $is\_jump$), sendo que se for um jump \texttt{True} ou \texttt{False}, é mandado o sinal proveniente do \emph{Flag Tester}, mas caso seja um outro tipo de salto (por exemplo, \texttt{Inconditional jump}), seja carregado na mesma o valor do salto e não PC+1.
			
		\subsection{WB}
		
		\subsection{Máquina de Estados}
		
	\section{Testes e Simulações}
	
		\subsection{Fibonacci}
		
	\section{Conclusão}
	
\end{document}
